"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_findindex_1 = __importDefault(require("lodash.findindex"));
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const lodash_difference_1 = __importDefault(require("lodash.difference"));
const lodash_flatmap_1 = __importDefault(require("lodash.flatmap"));
const lodash_map_1 = __importDefault(require("lodash.map"));
const lodash_filter_1 = __importDefault(require("lodash.filter"));
const lodash_find_1 = __importDefault(require("lodash.find"));
const zos_lib_1 = require("zos-lib");
const naming_1 = require("../../utils/naming");
const ZosVersion_1 = require("./ZosVersion");
const interfaces_1 = require("../../scripts/interfaces");
class ZosNetworkFile {
    static getZosversion(network) {
        const file = zos_lib_1.FileSystem.parseJsonIfExists(`zos.${network}.json`);
        return file ? file.zosversion : null;
    }
    static getDependencies(fileName) {
        const file = zos_lib_1.FileSystem.parseJsonIfExists(fileName);
        return file ? file.dependencies : undefined;
    }
    // TS-TODO: type for network parameter (and class member too).
    constructor(packageFile, network, fileName) {
        this.packageFile = packageFile;
        this.network = network;
        this.fileName = fileName;
        const defaults = {
            contracts: {},
            solidityLibs: {},
            proxies: {},
            zosversion: ZosVersion_1.ZOS_VERSION,
        };
        try {
            this.data = zos_lib_1.FileSystem.parseJsonIfExists(this.fileName) || defaults;
            // if we failed to read and parse zos.json
        }
        catch (e) {
            e.message = `Failed to parse '${path_1.default.resolve(fileName)}' file. Please make sure that ${fileName} is a valid JSON file. Details: ${e.message}.`;
            throw e;
        }
        ZosVersion_1.checkVersion(this.data.zosversion, this.fileName);
    }
    set zosversion(version) {
        this.data.zosversion = version;
    }
    get zosversion() {
        return this.data.zosversion;
    }
    set version(version) {
        this.data.version = version;
    }
    get version() {
        return this.data.version;
    }
    set contracts(contracts) {
        this.data.contracts = contracts;
    }
    get contracts() {
        return this.data.contracts || {};
    }
    set solidityLibs(solidityLibs) {
        this.data.solidityLibs = solidityLibs;
    }
    get solidityLibs() {
        return this.data.solidityLibs || {};
    }
    set frozen(frozen) {
        this.data.frozen = frozen;
    }
    get frozen() {
        return this.data.frozen;
    }
    set proxyAdmin(admin) {
        this.data.proxyAdmin = admin;
    }
    get proxyAdmin() {
        return this.data.proxyAdmin || {};
    }
    set proxyFactory(factory) {
        this.data.proxyFactory = factory;
    }
    get proxyFactory() {
        return this.data.proxyFactory || {};
    }
    set app(app) {
        this.data.app = app;
    }
    get app() {
        return this.data.app || {};
    }
    set provider(provider) {
        this.data.provider = provider;
    }
    get provider() {
        return this.data.provider || {};
    }
    set package(_package) {
        this.data.package = _package;
    }
    get package() {
        return this.data.package || {};
    }
    get proxyAdminAddress() {
        return this.proxyAdmin.address;
    }
    get proxyFactoryAddress() {
        return this.proxyFactory.address;
    }
    get appAddress() {
        return this.app.address;
    }
    get packageAddress() {
        return this.package.address;
    }
    get providerAddress() {
        return this.provider.address;
    }
    get isPublished() {
        return this.packageFile.isPublished;
    }
    get contractAliases() {
        return Object.keys(this.contracts);
    }
    addSolidityLib(libName, instance) {
        this.data.solidityLibs[libName] = {
            address: instance.address,
            constructorCode: zos_lib_1.constructorCode(instance),
            bodyBytecodeHash: zos_lib_1.bytecodeDigest(zos_lib_1.bodyCode(instance)),
            localBytecodeHash: zos_lib_1.bytecodeDigest(instance.schema.bytecode),
            deployedBytecodeHash: zos_lib_1.bytecodeDigest(instance.schema.linkedBytecode),
        };
    }
    unsetSolidityLib(libName) {
        delete this.data.solidityLibs[libName];
    }
    setSolidityLib(alias, value) {
        if (!this.data.solidityLibs)
            this.data.solidityLibs = {};
        this.data.solidityLibs[alias] = value;
    }
    solidityLib(libName) {
        return this.data.solidityLibs[libName];
    }
    getSolidityLibs(libs) {
        const { solidityLibs } = this.data;
        return Object.keys(solidityLibs)
            .filter(libName => libs.includes(libName))
            .map(libName => ({ libName, address: solidityLibs[libName].address }))
            .reduce((someLib, currentLib) => {
            someLib[currentLib.libName] = currentLib.address;
            return someLib;
        }, {});
    }
    hasSolidityLib(libName) {
        return !lodash_isempty_1.default(this.solidityLib(libName));
    }
    solidityLibsMissing(libs) {
        return lodash_difference_1.default(Object.keys(this.solidityLibs), libs);
    }
    getSolidityLibOrContract(aliasOrName) {
        return (this.data.solidityLibs[aliasOrName] || this.data.contracts[aliasOrName]);
    }
    hasSolidityLibOrContract(aliasOrName) {
        return this.hasSolidityLib(aliasOrName) || this.hasContract(aliasOrName);
    }
    updateImplementation(aliasOrName, fn) {
        if (this.hasContract(aliasOrName))
            this.data.contracts[aliasOrName] = fn(this.data.contracts[aliasOrName]);
        else if (this.hasSolidityLib(aliasOrName))
            this.data.solidityLibs[aliasOrName] = fn(this.data.solidityLibs[aliasOrName]);
        else
            return;
    }
    get dependencies() {
        return this.data.dependencies || {};
    }
    get dependenciesNames() {
        return Object.keys(this.dependencies);
    }
    getDependency(name) {
        if (!this.data.dependencies)
            return null;
        return this.data.dependencies[name] || {};
    }
    hasDependency(name) {
        return !lodash_isempty_1.default(this.getDependency(name));
    }
    hasDependencies() {
        return !lodash_isempty_1.default(this.dependencies);
    }
    getProxies({ package: packageName, contract, address, kind, } = {}) {
        if (lodash_isempty_1.default(this.data.proxies))
            return [];
        const allProxies = lodash_flatmap_1.default(this.data.proxies || {}, (proxiesList, fullname) => lodash_map_1.default(proxiesList, proxyInfo => (Object.assign({}, naming_1.fromContractFullName(fullname), proxyInfo, { kind: proxyInfo.kind || interfaces_1.ProxyType.Upgradeable }))));
        return lodash_filter_1.default(allProxies, proxy => (!packageName || proxy.package === packageName) &&
            (!contract || proxy.contract === contract) &&
            (!address || proxy.address === address) &&
            (!kind || proxy.kind === kind));
    }
    getProxy(address) {
        const allProxies = this.getProxies();
        return lodash_find_1.default(allProxies, { address });
    }
    contract(alias) {
        return this.data.contracts[alias];
    }
    contractAliasesMissingFromPackage() {
        return lodash_difference_1.default(this.contractAliases, this.packageFile.contractAliases);
    }
    isCurrentVersion(version) {
        return this.version === version;
    }
    hasContract(alias) {
        return !lodash_isempty_1.default(this.contract(alias));
    }
    hasContracts() {
        return !lodash_isempty_1.default(this.data.contracts);
    }
    hasProxies(aFilter = {}) {
        return !lodash_isempty_1.default(this.getProxies(aFilter));
    }
    hasMatchingVersion() {
        return this.packageFile.isCurrentVersion(this.version);
    }
    dependenciesNamesMissingFromPackage() {
        return lodash_difference_1.default(this.dependenciesNames, this.packageFile.dependenciesNames);
    }
    dependencyHasCustomDeploy(name) {
        const dep = this.getDependency(name);
        return dep && dep.customDeploy;
    }
    dependencySatisfiesVersionRequirement(name) {
        const dep = this.getDependency(name);
        return dep && this.packageFile.dependencyMatches(name, dep.version);
    }
    dependencyHasMatchingCustomDeploy(name) {
        return (this.dependencyHasCustomDeploy(name) &&
            this.dependencySatisfiesVersionRequirement(name));
    }
    hasSameBytecode(alias, klass) {
        const contract = this.contract(alias) || this.solidityLib(alias);
        if (contract) {
            const localBytecode = contract.localBytecodeHash;
            const currentBytecode = zos_lib_1.bytecodeDigest(klass.schema.bytecode);
            return currentBytecode === localBytecode;
        }
    }
    setDependency(name, { package: thepackage, version, customDeploy } = {}) {
        if (!this.data.dependencies)
            this.data.dependencies = {};
        const dependency = {
            package: thepackage,
            version: zos_lib_1.semanticVersionToString(version),
            customDeploy: undefined,
        };
        if (customDeploy)
            dependency.customDeploy = customDeploy;
        this.data.dependencies[name] = dependency;
    }
    unsetDependency(name) {
        if (!this.data.dependencies)
            return;
        delete this.data.dependencies[name];
    }
    updateDependency(name, fn) {
        this.setDependency(name, fn(this.getDependency(name)));
    }
    addContract(alias, instance, { warnings, types, storage, } = {}) {
        this.setContract(alias, {
            address: instance.address,
            constructorCode: zos_lib_1.constructorCode(instance),
            bodyBytecodeHash: zos_lib_1.bytecodeDigest(zos_lib_1.bodyCode(instance)),
            localBytecodeHash: zos_lib_1.bytecodeDigest(instance.schema.bytecode),
            deployedBytecodeHash: zos_lib_1.bytecodeDigest(instance.schema.linkedBytecode),
            types,
            storage,
            warnings,
        });
    }
    setContract(alias, value) {
        this.data.contracts[alias] = value;
    }
    unsetContract(alias) {
        delete this.data.contracts[alias];
    }
    setProxies(packageName, alias, value) {
        const fullname = naming_1.toContractFullName(packageName, alias);
        this.data.proxies[fullname] = value;
    }
    addProxy(thepackage, alias, info) {
        const fullname = naming_1.toContractFullName(thepackage, alias);
        if (!this.data.proxies[fullname])
            this.data.proxies[fullname] = [];
        this.data.proxies[fullname].push(info);
    }
    removeProxy(thepackage, alias, address) {
        const fullname = naming_1.toContractFullName(thepackage, alias);
        const index = this._indexOfProxy(fullname, address);
        if (index < 0)
            return;
        this.data.proxies[fullname].splice(index, 1);
        if (this._proxiesOf(fullname).length === 0)
            delete this.data.proxies[fullname];
    }
    updateProxy({ package: proxyPackageName, contract: proxyContractName, address: proxyAddress, }, fn) {
        const fullname = naming_1.toContractFullName(proxyPackageName, proxyContractName);
        const index = this._indexOfProxy(fullname, proxyAddress);
        if (index === -1)
            throw Error(`Proxy ${fullname} at ${proxyAddress} not found in network file`);
        this.data.proxies[fullname][index] = fn(this.data.proxies[fullname][index]);
    }
    _indexOfProxy(fullname, address) {
        return lodash_findindex_1.default(this.data.proxies[fullname], { address });
    }
    _proxiesOf(fullname) {
        return this.data.proxies[fullname] || [];
    }
    write() {
        if (this.hasChanged()) {
            const exists = this.exists();
            zos_lib_1.FileSystem.writeJson(this.fileName, this.data);
            zos_lib_1.Loggy.onVerbose(__filename, 'write', 'write-zos-json', exists ? `Updated ${this.fileName}` : `Created ${this.fileName}`);
        }
    }
    hasChanged() {
        const currentNetworkFile = zos_lib_1.FileSystem.parseJsonIfExists(this.fileName);
        return !lodash_isequal_1.default(this.data, currentNetworkFile);
    }
    exists() {
        return zos_lib_1.FileSystem.exists(this.fileName);
    }
}
exports.default = ZosNetworkFile;
//# sourceMappingURL=ZosNetworkFile.js.map