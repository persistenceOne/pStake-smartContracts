"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_pickby_1 = __importDefault(require("lodash.pickby"));
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const zos_lib_1 = require("zos-lib");
const Dependency_1 = __importDefault(require("../dependency/Dependency"));
const ZosVersion_1 = require("./ZosVersion");
const ZosNetworkFile_1 = __importDefault(require("./ZosNetworkFile"));
class ZosPackageFile {
    static getLinkedDependencies(fileName = 'zos.json') {
        const file = zos_lib_1.FileSystem.parseJsonIfExists(fileName);
        if (file && file.dependencies) {
            return Object.keys(file.dependencies).map(depName => `${depName}@${file.dependencies[depName]}`);
        }
        else
            return [];
    }
    constructor(fileName = 'zos.json') {
        this.fileName = fileName;
        try {
            this.data = zos_lib_1.FileSystem.parseJsonIfExists(this.fileName) || {
                zosversion: ZosVersion_1.ZOS_VERSION,
            };
            // if we failed to read and parse zos.json
        }
        catch (e) {
            e.message = `Failed to parse '${path_1.default.resolve(fileName)}' file. Please make sure that ${fileName} is a valid JSON file. Details: ${e.message}.`;
            throw e;
        }
        ZosVersion_1.checkVersion(this.data.zosversion, this.fileName);
        if (!this.data.contracts)
            this.data.contracts = {};
        if (!this.data.dependencies)
            this.data.dependencies = {};
    }
    exists() {
        return zos_lib_1.FileSystem.exists(this.fileName);
    }
    get root() {
        return path_1.default.dirname(this.fileName);
    }
    set zosversion(version) {
        this.data.zosversion = version;
    }
    set publish(publish) {
        this.data.publish = !!publish;
    }
    set name(name) {
        this.data.name = name;
    }
    get name() {
        return this.data.name;
    }
    set version(version) {
        this.data.version = version;
    }
    get version() {
        return this.data.version;
    }
    set contracts(contracts) {
        this.data.contracts = contracts;
    }
    get contracts() {
        return this.data.contracts || {};
    }
    get dependencies() {
        return this.data.dependencies || {};
    }
    get dependenciesNames() {
        return Object.keys(this.dependencies);
    }
    getDependencyVersion(name) {
        return this.dependencies[name];
    }
    hasDependency(name) {
        return !!this.dependencies[name];
    }
    hasDependencies() {
        return !lodash_isempty_1.default(this.dependencies);
    }
    get contractAliases() {
        return Object.keys(this.contracts);
    }
    get contractNames() {
        return Object.values(this.contracts);
    }
    get isPublished() {
        return !!this.data.publish;
    }
    get compilerOptions() {
        // Awkward destructuring is due to https://github.com/microsoft/TypeScript/issues/26235
        const config = this.data.compiler;
        const manager = config && config.manager;
        const version = config && config.solcVersion;
        const inputDir = config && config.contractsDir;
        const outputDir = config && config.artifactsDir;
        const compilerSettings = config && config.compilerSettings;
        const evmVersion = compilerSettings && compilerSettings.evmVersion;
        const optimizer = compilerSettings && compilerSettings.optimizer;
        return {
            manager,
            inputDir,
            outputDir,
            evmVersion,
            version,
            optimizer: {
                enabled: optimizer && optimizer.enabled,
                runs: optimizer && optimizer.runs && parseInt(optimizer.runs),
            },
        };
    }
    setCompilerOptions(options) {
        const { manager, version, outputDir, inputDir, evmVersion, optimizer, } = options;
        const configOptions = {
            manager,
            solcVersion: version,
            artifactsDir: outputDir,
            contractsDir: inputDir,
            compilerSettings: {
                evmVersion,
                optimizer: {
                    enabled: optimizer && optimizer.enabled,
                    runs: optimizer && optimizer.runs && optimizer.runs.toString(),
                },
            },
        };
        this.data.compiler =
            manager === 'trufle'
                ? { manager: 'truffle' }
                : lodash_pickby_1.default(Object.assign({}, this.data.compiler, configOptions));
    }
    contract(alias) {
        return this.contracts[alias];
    }
    hasName(name) {
        return this.name === name;
    }
    dependencyMatches(name, version) {
        return (this.hasDependency(name) &&
            Dependency_1.default.satisfiesVersion(version, this.getDependencyVersion(name)));
    }
    isCurrentVersion(version) {
        return this.version === version;
    }
    hasContract(alias) {
        return !!this.contract(alias);
    }
    hasContracts() {
        return !lodash_isempty_1.default(this.contracts);
    }
    setDependency(name, version) {
        if (!this.data.dependencies)
            this.data.dependencies = {};
        this.data.dependencies[name] = version;
    }
    unsetDependency(name) {
        if (!this.data.dependencies)
            return;
        delete this.data.dependencies[name];
    }
    addContract(alias, name) {
        this.data.contracts[alias] = name || alias;
    }
    unsetContract(alias) {
        delete this.data.contracts[alias];
    }
    networkFile(network) {
        const networkFileName = this.fileName.replace(/\.json\s*$/, `.${network}.json`);
        if (networkFileName === this.fileName)
            throw Error(`Cannot create network file name from ${this.fileName}`);
        return new ZosNetworkFile_1.default(this, network, networkFileName);
    }
    write() {
        if (this.hasChanged()) {
            const exists = this.exists();
            zos_lib_1.FileSystem.writeJson(this.fileName, this.data);
            zos_lib_1.Loggy.onVerbose(__filename, 'write', 'write-zos-json', exists ? `Updated ${this.fileName}` : `Created ${this.fileName}`);
        }
    }
    hasChanged() {
        const currentPackgeFile = zos_lib_1.FileSystem.parseJsonIfExists(this.fileName);
        return !lodash_isequal_1.default(this.data, currentPackgeFile);
    }
}
exports.default = ZosPackageFile;
//# sourceMappingURL=ZosPackageFile.js.map