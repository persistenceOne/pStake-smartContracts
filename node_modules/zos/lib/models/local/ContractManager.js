"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zos_lib_1 = require("zos-lib");
const Dependency_1 = __importDefault(require("../dependency/Dependency"));
const ZosPackageFile_1 = __importDefault(require("../files/ZosPackageFile"));
const ConfigManager_1 = __importDefault(require("../config/ConfigManager"));
const path_1 = __importDefault(require("path"));
class ContractManager {
    constructor(packageFile = new ZosPackageFile_1.default()) {
        this.packageFile = packageFile;
    }
    getContractClass(packageName, contractAlias) {
        if (!packageName || packageName === this.packageFile.name) {
            const contractName = this.packageFile.contract(contractAlias);
            return zos_lib_1.Contracts.getFromLocal(contractName);
        }
        else {
            const dependency = new Dependency_1.default(packageName);
            const contractName = dependency.getPackageFile().contract(contractAlias);
            return zos_lib_1.Contracts.getFromNodeModules(packageName, contractName);
        }
    }
    hasContract(packageName, contractAlias) {
        if (!packageName || packageName === this.packageFile.name) {
            return !!this.packageFile.contract(contractAlias);
        }
        else {
            const dependency = new Dependency_1.default(packageName);
            return !!dependency.getPackageFile().contract(contractAlias);
        }
    }
    getContractNames(root = this.packageFile.root) {
        const buildDir = ConfigManager_1.default.getBuildDir();
        const contractsDir = zos_lib_1.Contracts.getLocalContractsDir();
        if (zos_lib_1.FileSystem.exists(buildDir)) {
            return zos_lib_1.FileSystem.readDir(buildDir)
                .filter(name => name.match(/\.json$/))
                .map(name => zos_lib_1.FileSystem.parseJsonIfExists(`${buildDir}/${name}`))
                .filter(contract => {
                return (this.isLocalContract(contractsDir, contract, root) &&
                    !this.isLibrary(contract) &&
                    !this.isAbstractContract(contract));
            })
                .map(({ contractName }) => contractName);
        }
        else
            return [];
    }
    isLocalContract(contractsDir, contract, root) {
        const cwd = root || process.cwd();
        const contractFullPath = path_1.default.resolve(cwd, contract.sourcePath);
        return contractFullPath.indexOf(contractsDir) === 0;
    }
    isAbstractContract(contract) {
        return contract && contract.bytecode.length <= 2;
    }
    isLibrary(contract) {
        return (contract &&
            contract.ast &&
            !!contract.ast.nodes.find(node => node.contractKind === 'library' &&
                node.name === contract.contractName));
    }
}
exports.default = ContractManager;
//# sourceMappingURL=ContractManager.js.map