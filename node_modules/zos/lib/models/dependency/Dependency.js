"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_map_1 = __importDefault(require("lodash.map"));
const lodash_uniq_1 = __importDefault(require("lodash.uniq"));
const lodash_flatten_1 = __importDefault(require("lodash.flatten"));
const lodash_frompairs_1 = __importDefault(require("lodash.frompairs"));
const semver_1 = __importDefault(require("semver"));
const npm_programmatic_1 = __importDefault(require("npm-programmatic"));
const child_process_1 = require("child_process");
const util_1 = require("util");
const zos_lib_1 = require("zos-lib");
const ZosPackageFile_1 = __importDefault(require("../files/ZosPackageFile"));
const ZosNetworkFile_1 = __importDefault(require("../files/ZosNetworkFile"));
class Dependency {
    static fromNameWithVersion(nameAndVersion) {
        const [name, version] = nameAndVersion.split('@');
        return new this(name, version);
    }
    static satisfiesVersion(version, requirement) {
        return (!requirement ||
            version === requirement ||
            semver_1.default.satisfies(semver_1.default.coerce(version), requirement));
    }
    static fetchVersionFromNpm(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const execAsync = util_1.promisify(child_process_1.exec);
            try {
                const { stdout } = yield execAsync(`npm view ${name} | grep latest`);
                const versionMatch = stdout.match(/([0-9]+\.){2}[0-9]+/);
                return Array.isArray(versionMatch) && versionMatch.length > 0
                    ? `${name}@${versionMatch[0]}`
                    : name;
            }
            catch (error) {
                return name;
            }
        });
    }
    static hasDependenciesForDeploy(network, packageFile, networkFile) {
        const dependencies = ZosPackageFile_1.default.getLinkedDependencies(packageFile || 'zos.json') || [];
        const networkDependencies = ZosNetworkFile_1.default.getDependencies(networkFile || `zos.${network}.json`) ||
            {};
        const hasDependenciesForDeploy = dependencies.find(depNameAndVersion => {
            const [name, version] = depNameAndVersion.split('@');
            const dependency = new Dependency(name);
            const networkFilePath = dependency._getNetworkFilePath(network);
            const projectDependency = networkDependencies[name];
            const satisfiesVersion = projectDependency &&
                this.satisfiesVersion(projectDependency.version, version);
            return !zos_lib_1.FileSystem.exists(networkFilePath) || !satisfiesVersion;
        });
        return !!hasDependenciesForDeploy;
    }
    static install(nameAndVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            zos_lib_1.Loggy.spin(__filename, 'install', `install-dependency-${nameAndVersion}`, `Installing ${nameAndVersion} via npm`);
            yield npm_programmatic_1.default.install([nameAndVersion], { save: true, cwd: process.cwd() });
            zos_lib_1.Loggy.succeed(`install-dependency-${nameAndVersion}`, `Dependency ${nameAndVersion} installed`);
            return this.fromNameWithVersion(nameAndVersion);
        });
    }
    constructor(name, requirement) {
        this.name = name;
        this._networkFiles = {};
        const packageVersion = this.getPackageFile().version;
        this._validateSatisfiesVersion(packageVersion, requirement);
        this.version = packageVersion;
        this.nameAndVersion = `${name}@${packageVersion}`;
        this.requirement = requirement || tryWithCaret(packageVersion);
    }
    deploy(txParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = semver_1.default.coerce(this.version).toString();
            const project = yield zos_lib_1.PackageProject.fetchOrDeploy(version, txParams, {});
            // REFACTOR: Logic for filling in solidity libraries is partially duplicated from network base controller,
            // this should all be handled at the Project level. Consider adding a setImplementations (plural) method
            // to Projects, which handle library deployment and linking for a set of contracts altogether.
            const contracts = lodash_map_1.default(this.getPackageFile().contracts, (contractName, contractAlias) => [
                zos_lib_1.Contracts.getFromNodeModules(this.name, contractName),
                contractAlias,
            ]);
            const pipeline = [
                someContracts => lodash_map_1.default(someContracts, ([contract]) => zos_lib_1.getSolidityLibNames(contract.schema.bytecode)),
                someContracts => lodash_flatten_1.default(someContracts),
                someContracts => lodash_uniq_1.default(someContracts),
            ];
            const libraryNames = pipeline.reduce((xs, f) => f(xs), contracts);
            const libraries = lodash_frompairs_1.default(yield Promise.all(lodash_map_1.default(libraryNames, (libraryName) => __awaiter(this, void 0, void 0, function* () {
                const implementation = yield project.setImplementation(zos_lib_1.Contracts.getFromNodeModules(this.name, libraryName), libraryName);
                return [libraryName, implementation.address];
            }))));
            yield Promise.all(lodash_map_1.default(contracts, ([contract, contractAlias]) => __awaiter(this, void 0, void 0, function* () {
                contract.link(libraries);
                yield project.setImplementation(contract, contractAlias);
            })));
            return project;
        });
    }
    getPackageFile() {
        if (!this._packageFile) {
            try {
                const filename = require.resolve(`${this.name}/zos.json`, {
                    paths: [process.cwd()],
                });
                this._packageFile = new ZosPackageFile_1.default(filename);
            }
            catch (err) {
                throw Error(`Could not find a zos.json file for '${this.name}'. (${err.message})`);
            }
        }
        return this._packageFile;
    }
    getNetworkFile(network) {
        if (!this._networkFiles[network]) {
            const filename = this._getNetworkFilePath(network);
            if (!zos_lib_1.FileSystem.exists(filename)) {
                throw Error(`Could not find a zos file for network '${network}' for '${this.name}'.`);
            }
            this._networkFiles[network] = new ZosNetworkFile_1.default(this.getPackageFile(), network, filename);
            this._validateSatisfiesVersion(this._networkFiles[network].version, this.requirement);
        }
        return this._networkFiles[network];
    }
    isDeployedOnNetwork(network) {
        const filename = this._getNetworkFilePath(network);
        if (!zos_lib_1.FileSystem.exists(filename))
            return false;
        return !!this.getNetworkFile(network).packageAddress;
    }
    _getNetworkFilePath(network) {
        try {
            return require.resolve(`${this.name}/zos.${network}.json`, {
                paths: [process.cwd()],
            });
        }
        catch (err) {
            return null;
        }
    }
    _validateSatisfiesVersion(version, requirement) {
        if (!Dependency.satisfiesVersion(version, requirement)) {
            throw Error(`Required dependency version ${requirement} does not match version ${version}`);
        }
    }
}
exports.default = Dependency;
function tryWithCaret(version) {
    const cleaned = semver_1.default.clean(version);
    return cleaned ? `^${cleaned}` : version;
}
//# sourceMappingURL=Dependency.js.map