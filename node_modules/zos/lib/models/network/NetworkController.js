'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const lodash_intersection_1 = __importDefault(require("lodash.intersection"));
const lodash_uniq_1 = __importDefault(require("lodash.uniq"));
const lodash_flatten_1 = __importDefault(require("lodash.flatten"));
const lodash_filter_1 = __importDefault(require("lodash.filter"));
const lodash_every_1 = __importDefault(require("lodash.every"));
const lodash_partition_1 = __importDefault(require("lodash.partition"));
const lodash_map_1 = __importDefault(require("lodash.map"));
const lodash_concat_1 = __importDefault(require("lodash.concat"));
const lodash_topairs_1 = __importDefault(require("lodash.topairs"));
const zos_lib_1 = require("zos-lib");
const ZosVersion_1 = require("../files/ZosVersion");
const async_1 = require("../../utils/async");
const naming_1 = require("../../utils/naming");
const ProjectDeployer_1 = require("./ProjectDeployer");
const Dependency_1 = __importDefault(require("../dependency/Dependency"));
const ValidationLogger_1 = __importDefault(require("../../interface/ValidationLogger"));
const Verifier_1 = __importDefault(require("../Verifier"));
const LocalController_1 = __importDefault(require("../local/LocalController"));
const ContractManager_1 = __importDefault(require("../local/ContractManager"));
const ZosPackageFile_1 = __importDefault(require("../files/ZosPackageFile"));
const ZosVersion_2 = require("../files/ZosVersion");
const interfaces_1 = require("../../scripts/interfaces");
class NetworkController {
    constructor(network, txParams, networkFile) {
        if (!networkFile) {
            const packageFile = new ZosPackageFile_1.default();
            this.networkFile = packageFile.networkFile(network);
        }
        else {
            this.networkFile = networkFile;
        }
        this.localController = new LocalController_1.default(this.networkFile.packageFile);
        this.contractManager = new ContractManager_1.default(this.networkFile.packageFile);
        this.txParams = txParams;
        this.network = network;
    }
    // NetworkController
    get packageFile() {
        return this.localController.packageFile;
    }
    // NetworkController
    get packageVersion() {
        return this.packageFile.version;
    }
    // NetworkController
    get currentVersion() {
        return this.networkFile.version;
    }
    get currentZosversion() {
        return this.networkFile.zosversion;
    }
    // NetworkController
    get packageAddress() {
        return this.networkFile.packageAddress;
    }
    get proxyAdminAddress() {
        return this.networkFile.proxyAdminAddress;
    }
    get proxyFactoryAddress() {
        return this.networkFile.proxyFactoryAddress;
    }
    // NetworkController
    checkNotFrozen() {
        if (this.networkFile.frozen) {
            throw Error('Cannot modify contracts in a frozen version. Run zos bump to create a new version first.');
        }
    }
    // DeployerController
    fetchOrDeploy(requestedVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            this.project = yield this.getDeployer(requestedVersion).fetchOrDeploy();
            return this.project;
        });
    }
    // DeployerController
    push(reupload = false, force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const changedLibraries = this._solidityLibsForPush(!reupload);
            const contracts = this._contractsListForPush(!reupload, changedLibraries);
            const buildArtifacts = zos_lib_1.getBuildArtifacts();
            // ValidateContracts also extends each contract class with validation errors and storage info
            if (!this.validateContracts(contracts, buildArtifacts) && !force) {
                throw Error('One or more contracts have validation errors. Please review the items listed above and fix them, or run this command again with the --force option.');
            }
            this._checkVersion();
            yield this.fetchOrDeploy(this.packageVersion);
            yield this.handleDependenciesLink();
            this.checkNotFrozen();
            yield this.uploadSolidityLibs(changedLibraries);
            yield Promise.all([this.uploadContracts(contracts), this.unsetContracts()]);
            yield this._unsetSolidityLibs();
            if (lodash_isempty_1.default(contracts) && lodash_isempty_1.default(changedLibraries)) {
                zos_lib_1.Loggy.noSpin(__filename, 'push', `after-push`, `All contracts are up to date`);
            }
            else {
                zos_lib_1.Loggy.noSpin(__filename, 'push', `after-push`, `All contracts have been deployed`);
            }
        });
    }
    // DeployerController
    deployProxyFactory() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fetchOrDeploy(this.packageVersion);
            yield this.project.ensureProxyFactory();
            yield this._tryRegisterProxyFactory();
        });
    }
    // DeployerController
    deployProxyAdmin() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fetchOrDeploy(this.packageVersion);
            yield this.project.ensureProxyAdmin();
            yield this._tryRegisterProxyAdmin();
        });
    }
    // DeployerController
    _checkVersion() {
        if (this._newVersionRequired()) {
            this.networkFile.frozen = false;
            this.networkFile.contracts = {};
        }
    }
    // DeployerController
    _newVersionRequired() {
        return this.packageVersion !== this.currentVersion && this.isPublished;
    }
    // Contract model
    _contractsListForPush(onlyChanged = false, changedLibraries = []) {
        const newVersion = this._newVersionRequired();
        const pipeline = [
            contracts => lodash_topairs_1.default(contracts),
            contracts => lodash_map_1.default(contracts, ([contractAlias, contractName]) => [
                contractAlias,
                zos_lib_1.Contracts.getFromLocal(contractName),
            ]),
            contracts => lodash_filter_1.default(contracts, ([contractAlias, contract]) => newVersion ||
                !onlyChanged ||
                this.hasContractChanged(contractAlias, contract) ||
                this._hasChangedLibraries(contract, changedLibraries)),
        ];
        return pipeline.reduce((xs, f) => f(xs), this.packageFile.contracts);
    }
    // Contract model || SolidityLib model
    _solidityLibsForPush(onlyChanged = false) {
        const { contractNames, contractAliases } = this.packageFile;
        const libNames = this._getAllSolidityLibNames(contractNames);
        const clashes = lodash_intersection_1.default(libNames, contractAliases);
        if (!lodash_isempty_1.default(clashes)) {
            throw new Error(`Cannot upload libraries with the same name as a contract alias: ${clashes.join(', ')}`);
        }
        return libNames
            .map(libName => zos_lib_1.Contracts.getFromLocal(libName))
            .filter(libClass => {
            const hasSolidityLib = this.networkFile.hasSolidityLib(libClass.schema.contractName);
            const hasChanged = this._hasSolidityLibChanged(libClass);
            return !hasSolidityLib || !onlyChanged || hasChanged;
        });
    }
    // Contract model || SolidityLib model
    uploadSolidityLibs(libs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(libs.map(lib => this._uploadSolidityLib(lib)));
        });
    }
    // Contract model || SolidityLib model
    _uploadSolidityLib(libClass) {
        return __awaiter(this, void 0, void 0, function* () {
            const libName = libClass.schema.contractName;
            zos_lib_1.Loggy.spin(__filename, '_uploadSolidityLib', `upload-solidity-lib${libName}`, `Uploading ${libName} library`);
            const libInstance = yield this.project.setImplementation(libClass, libName);
            this.networkFile.addSolidityLib(libName, libInstance);
            zos_lib_1.Loggy.succeed(`upload-solidity-lib${libName}`, `${libName} library uploaded`);
        });
    }
    // Contract model
    uploadContracts(contracts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(contracts.map(([contractAlias, contract]) => this.uploadContract(contractAlias, contract)));
        });
    }
    // Contract model
    uploadContract(contractAlias, contract) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._setSolidityLibs(contract);
                zos_lib_1.Loggy.spin(__filename, 'uploadContract', `upload-contract${contract.schema.contractName}`, `Validating and deploying contract ${contract.schema.contractName}`);
                const contractInstance = yield this.project.setImplementation(contract, contractAlias);
                const { types, storage } = contract.schema.storageInfo || {
                    types: null,
                    storage: null,
                };
                this.networkFile.addContract(contractAlias, contractInstance, {
                    warnings: contract.schema.warnings,
                    types,
                    storage,
                });
                zos_lib_1.Loggy.succeed(`upload-contract${contract.schema.contractName}`, `Contract ${contract.schema.contractName} deployed`);
            }
            catch (error) {
                error.message = `${contractAlias} deployment failed with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Contract model || SolidityLib model
    _setSolidityLibs(contract) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentContractLibs = zos_lib_1.getSolidityLibNames(contract.schema.bytecode);
            const libraries = this.networkFile.getSolidityLibs(currentContractLibs);
            contract.link(libraries);
        });
    }
    // Contract model || SolidityLib model
    _unsetSolidityLibs() {
        return __awaiter(this, void 0, void 0, function* () {
            const { contractNames } = this.packageFile;
            const libNames = this._getAllSolidityLibNames(contractNames);
            yield async_1.allPromisesOrError(this.networkFile
                .solidityLibsMissing(libNames)
                .map(libName => this._unsetSolidityLib(libName)));
        });
    }
    // Contract model || SolidityLib model
    _unsetSolidityLib(libName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                zos_lib_1.Loggy.spin(__filename, '_unsetSolidityLib', `unset-solidity-lib-${libName}`, `Removing ${libName} library`);
                yield this.project.unsetImplementation(libName);
                this.networkFile.unsetSolidityLib(libName);
                zos_lib_1.Loggy.succeed(`unset-solidity-lib-${libName}`);
            }
            catch (error) {
                error.message = `Removal of ${libName} failed with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Contract model || SolidityLib model
    _hasChangedLibraries(contract, changedLibraries) {
        const libNames = zos_lib_1.getSolidityLibNames(contract.schema.bytecode);
        return !lodash_isempty_1.default(lodash_intersection_1.default(changedLibraries.map(c => c.schema.contractName), libNames));
    }
    // Contract model || SolidityLib model
    _getAllSolidityLibNames(contractNames) {
        const libNames = contractNames.map(contractName => {
            const contract = zos_lib_1.Contracts.getFromLocal(contractName);
            return zos_lib_1.getSolidityLibNames(contract.schema.bytecode);
        });
        return lodash_uniq_1.default(lodash_flatten_1.default(libNames));
    }
    // Contract model
    unsetContracts() {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(this.networkFile
                .contractAliasesMissingFromPackage()
                .map(contractAlias => this.unsetContract(contractAlias)));
        });
    }
    // Contract model
    unsetContract(contractAlias) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                zos_lib_1.Loggy.spin(__filename, 'unsetContract', `unset-contract-${contractAlias}`, `Removing ${contractAlias} contract`);
                yield this.project.unsetImplementation(contractAlias);
                this.networkFile.unsetContract(contractAlias);
                zos_lib_1.Loggy.succeed(`unset-contract-${contractAlias}`);
            }
            catch (error) {
                error.message = `Removal of ${contractAlias} failed with error: ${error.message}`;
                throw error;
            }
        });
    }
    // DeployerController || Contract model
    validateContracts(contracts, buildArtifacts) {
        return lodash_every_1.default(contracts.map(([contractAlias, contract]) => this.validateContract(contractAlias, contract, buildArtifacts)));
    }
    // DeployerController || Contract model
    validateContract(contractAlias, contract, buildArtifacts) {
        try {
            const existingContractInfo = this.networkFile.contract(contractAlias) || {};
            const warnings = zos_lib_1.validate(contract, existingContractInfo, buildArtifacts);
            const newWarnings = zos_lib_1.newValidationErrors(warnings, existingContractInfo.warnings);
            const validationLogger = new ValidationLogger_1.default(contract, existingContractInfo);
            validationLogger.log(newWarnings, buildArtifacts);
            contract.schema.warnings = warnings;
            contract.schema.storageInfo = zos_lib_1.getStorageLayout(contract, buildArtifacts);
            return zos_lib_1.validationPasses(newWarnings);
        }
        catch (err) {
            zos_lib_1.Loggy.noSpin.error(__filename, 'validateContract', `validate-contract`, `Error while validating contract ${contract.schema.contractName}: ${err}`);
            return false;
        }
    }
    // Contract model
    checkContractDeployed(packageName, contractAlias, throwIfFail = false) {
        if (!packageName)
            packageName = this.packageFile.name;
        const err = this._errorForContractDeployed(packageName, contractAlias);
        if (err)
            this._handleErrorMessage(err, throwIfFail);
    }
    // Contract model
    checkLocalContractsDeployed(throwIfFail = false) {
        const err = this._errorForLocalContractsDeployed();
        if (err)
            this._handleErrorMessage(err, throwIfFail);
    }
    // Contract model
    _errorForLocalContractsDeployed() {
        const [contractsDeployed, contractsMissing] = lodash_partition_1.default(this.packageFile.contractAliases, alias => this.isContractDeployed(alias));
        const contractsChanged = lodash_filter_1.default(contractsDeployed, alias => this.hasContractChanged(alias));
        if (!lodash_isempty_1.default(contractsMissing)) {
            return `Contracts ${contractsMissing.join(', ')} are not deployed.`;
        }
        else if (!lodash_isempty_1.default(contractsChanged)) {
            return `Contracts ${contractsChanged.join(', ')} have changed since the last deploy.`;
        }
    }
    // Contract model
    checkLocalContractDeployed(contractAlias, throwIfFail = false) {
        // if (!packageName) packageName = this.packageFile.name
        const err = this._errorForLocalContractDeployed(contractAlias);
        if (err)
            this._handleErrorMessage(err, throwIfFail);
    }
    // Contract model
    _errorForLocalContractDeployed(contractAlias) {
        if (!this.isContractDefined(contractAlias)) {
            return `Contract ${contractAlias} not found in this project`;
        }
        else if (!this.isContractDeployed(contractAlias)) {
            return `Contract ${contractAlias} is not deployed to ${this.network}.`;
        }
        else if (this.hasContractChanged(contractAlias)) {
            return `Contract ${contractAlias} has changed locally since the last deploy, consider running 'zos push'.`;
        }
    }
    // TODO: move to utils folder or somewhere else
    _handleErrorMessage(msg, throwIfFail = false) {
        if (throwIfFail) {
            throw Error(msg);
        }
        else {
            zos_lib_1.Loggy.noSpin(__filename, 'handleErrorMessage', `handle-error-message`, msg);
        }
    }
    // Contract model || SolidityLib model
    _hasSolidityLibChanged(libClass) {
        return !this.networkFile.hasSameBytecode(libClass.schema.contractName, libClass);
    }
    // Contract model
    hasContractChanged(contractAlias, contract) {
        if (!this.isLocalContract(contractAlias))
            return false;
        if (!this.isContractDeployed(contractAlias))
            return true;
        if (!contract) {
            const contractName = this.packageFile.contract(contractAlias);
            contract = zos_lib_1.Contracts.getFromLocal(contractName);
        }
        return !this.networkFile.hasSameBytecode(contractAlias, contract);
    }
    // Contract model
    isLocalContract(contractAlias) {
        return this.packageFile.hasContract(contractAlias);
    }
    // Contract model
    isContractDefined(contractAlias) {
        return this.packageFile.hasContract(contractAlias);
    }
    // Contract model
    isContractDeployed(contractAlias) {
        return (!this.isLocalContract(contractAlias) ||
            this.networkFile.hasContract(contractAlias));
    }
    // VerifierController
    verifyAndPublishContract(contractAlias, optimizer, optimizerRuns, remote, apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            zos_lib_1.Loggy.spin(__filename, 'verifyAndPublishContract', 'verify-and-publish', `Verifying and publishing contract source code of ${contractAlias} on ${remote} (this usually takes under 30 seconds)`);
            const contractName = this.packageFile.contract(contractAlias);
            const { compilerVersion, sourcePath, } = this.localController.getContractSourcePath(contractAlias);
            const contractSource = yield zos_lib_1.flattenSourceCode([sourcePath]);
            const contractAddress = this.networkFile.contracts[contractAlias].address;
            yield Verifier_1.default.verifyAndPublish(remote, {
                contractName,
                compilerVersion,
                optimizer,
                optimizerRuns,
                contractSource,
                contractAddress,
                apiKey,
                network: this.network,
            });
        });
    }
    // NetworkController
    writeNetworkPackageIfNeeded() {
        this.networkFile.write();
        this.packageFile.write();
    }
    // DeployerController
    freeze() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.packageAddress)
                throw Error('Cannot freeze an unpublished project');
            yield this.fetchOrDeploy(this.currentVersion);
            if (this.project instanceof zos_lib_1.AppProject)
                yield this.project.freeze();
            this.networkFile.frozen = true;
        });
    }
    // DeployerController
    get isPublished() {
        return this.packageFile.isPublished || this.appAddress !== undefined;
    }
    // DeployerController
    getDeployer(requestedVersion) {
        return this.isPublished
            ? new ProjectDeployer_1.AppProjectDeployer(this, requestedVersion)
            : new ProjectDeployer_1.ProxyAdminProjectDeployer(this, requestedVersion);
    }
    // NetworkController
    get appAddress() {
        return this.networkFile.appAddress;
    }
    // NetworkController
    get app() {
        if (this.project instanceof zos_lib_1.AppProject)
            return this.project.getApp();
        else
            return null;
    }
    _migrate() {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = this.isPublished ? this.appAddress : this.txParams.from;
            const proxies = this._fetchOwnedProxies(null, null, null, owner);
            if (proxies.length !== 0) {
                const proxyAdmin = this.proxyAdminAddress
                    ? yield zos_lib_1.ProxyAdmin.fetch(this.proxyAdminAddress, this.txParams)
                    : yield zos_lib_1.ProxyAdmin.deploy(this.txParams);
                if (!this.proxyAdminAddress) {
                    zos_lib_1.Loggy.spin(__filename, 'fetchOrDeploy', 'await-confirmations', 'Awaiting confirmations before transferring proxies to ProxyAdmin (this may take a few minutes)');
                    yield zos_lib_1.Transactions.awaitConfirmations(proxyAdmin.contract.deployment.transactionHash);
                    zos_lib_1.Loggy.succeed('await-confirmations');
                }
                this._tryRegisterProxyAdmin(proxyAdmin.address);
                yield async_1.allPromisesOrError(lodash_map_1.default(proxies, (proxy) => __awaiter(this, void 0, void 0, function* () {
                    const proxyInstance = yield zos_lib_1.Proxy.at(proxy.address);
                    const currentAdmin = yield proxyInstance.admin();
                    if (currentAdmin !== proxyAdmin.address) {
                        if (this.appAddress) {
                            return zos_lib_1.AppProxyMigrator(this.appAddress, proxy.address, proxyAdmin.address, this.txParams);
                        }
                        else {
                            const simpleProject = new zos_lib_1.SimpleProject(this.packageFile.name, null, this.txParams);
                            return simpleProject.changeProxyAdmin(proxy.address, proxyAdmin.address);
                        }
                    }
                })));
                zos_lib_1.Loggy.noSpin(__filename, '_migrate', 'migrate-version-cli', `Successfully migrated to zosversion ${ZosVersion_2.ZOS_VERSION}`);
            }
            else {
                zos_lib_1.Loggy.noSpin(__filename, '_migrate', 'migrate-version-cli', `No proxies were found. Updating zosversion to ${ZosVersion_2.ZOS_VERSION}`);
            }
        });
    }
    _migrateZosversionIfNeeded() {
        return __awaiter(this, void 0, void 0, function* () {
            if (ZosVersion_1.isMigratableZosversion(this.currentZosversion))
                yield this._migrate();
            this._updateZosVersionsIfNeeded(ZosVersion_2.ZOS_VERSION);
        });
    }
    // DeployerController
    publish() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.appAddress) {
                zos_lib_1.Loggy.noSpin(__filename, 'publish', `Project is already published to ${this.network}`);
                return;
            }
            yield this._migrateZosversionIfNeeded();
            const proxyAdminProject = (yield this.fetchOrDeploy(this.currentVersion));
            const deployer = new ProjectDeployer_1.AppProjectDeployer(this, this.packageVersion);
            this.project = yield deployer.fromProxyAdminProject(proxyAdminProject);
            zos_lib_1.Loggy.succeed(`publish-project`, `Published to ${this.network}!`);
        });
    }
    // Proxy model
    createProxy(packageName, contractAlias, initMethod, initArgs, admin, salt, signature, kind) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._migrateZosversionIfNeeded();
                yield this.fetchOrDeploy(this.currentVersion);
                if (!packageName)
                    packageName = this.packageFile.name;
                const contract = this.contractManager.getContractClass(packageName, contractAlias);
                yield this._setSolidityLibs(contract);
                this.checkInitialization(contract, initMethod);
                if (salt)
                    yield this._checkDeploymentAddress(salt);
                const createArgs = {
                    packageName,
                    contractName: contractAlias,
                    initMethod,
                    initArgs,
                    admin,
                };
                const { proxy, instance } = yield this.createProxyInstance(kind, salt, contract, signature, createArgs);
                const implementationAddress = yield proxy.implementation();
                const packageVersion = packageName === this.packageFile.name
                    ? this.currentVersion
                    : yield this.project.getDependencyVersion(packageName);
                yield this._updateTruffleDeployedInformation(contractAlias, instance);
                this.networkFile.addProxy(packageName, contractAlias, {
                    address: instance.address,
                    version: zos_lib_1.semanticVersionToString(packageVersion),
                    implementation: implementationAddress,
                    admin: admin ||
                        this.networkFile.proxyAdminAddress ||
                        (yield this.project.getAdminAddress()),
                    kind,
                });
                return instance;
            }
            finally {
                yield this._tryRegisterProxyAdmin();
                yield this._tryRegisterProxyFactory();
            }
        });
    }
    createProxyInstance(kind, salt, contract, signature, createArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            let instance, proxy;
            switch (kind) {
                case interfaces_1.ProxyType.Upgradeable:
                    instance = salt
                        ? yield this.project.createProxyWithSalt(contract, salt, signature, createArgs)
                        : yield this.project.createProxy(contract, createArgs);
                    proxy = yield zos_lib_1.Proxy.at(instance.address);
                    break;
                case interfaces_1.ProxyType.Minimal:
                    if (salt) {
                        throw new Error(`Cannot create a minimal proxy with a precomputed address, use an Upgradeable proxy instead.`);
                    }
                    instance = yield this.project.createMinimalProxy(contract, createArgs);
                    proxy = yield zos_lib_1.MinimalProxy.at(instance.address);
                    break;
                default:
                    throw new Error(`Unknown proxy type ${kind}`);
            }
            return { proxy, instance };
        });
    }
    getProxyDeploymentAddress(salt, sender) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            yield this.fetchOrDeploy(this.currentVersion);
            const address = yield this.project.getProxyDeploymentAddress(salt, sender);
            this._tryRegisterProxyFactory();
            return address;
        });
    }
    getProxySignedDeployment(salt, signature, packageName, contractAlias, initMethod, initArgs, admin) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            yield this.fetchOrDeploy(this.currentVersion);
            if (!packageName)
                packageName = this.packageFile.name;
            const contract = this.contractManager.getContractClass(packageName, contractAlias);
            const args = {
                packageName,
                contractName: contractAlias,
                initMethod,
                initArgs,
                admin,
            };
            const signer = yield this.project.getProxyDeploymentSigner(contract, salt, signature, args);
            const address = yield this.project.getProxyDeploymentAddress(salt, signer);
            this._tryRegisterProxyFactory();
            return { address, signer };
        });
    }
    // Proxy model
    _checkDeploymentAddress(salt) {
        return __awaiter(this, void 0, void 0, function* () {
            const deploymentAddress = yield this.getProxyDeploymentAddress(salt);
            if ((yield zos_lib_1.ZWeb3.getCode(deploymentAddress)) !== '0x')
                throw new Error(`Deployment address for salt ${salt} is already in use`);
        });
    }
    // Proxy model
    _tryRegisterProxyAdmin(adminAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.networkFile.proxyAdminAddress) {
                const proxyAdminAddress = adminAddress || (yield this.project.getAdminAddress());
                if (proxyAdminAddress)
                    this.networkFile.proxyAdmin = { address: proxyAdminAddress };
            }
        });
    }
    // Proxy model
    _tryRegisterProxyFactory(factoryAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.networkFile.proxyFactoryAddress) {
                const proxyFactoryAddress = factoryAddress ||
                    (this.project.proxyFactory && this.project.proxyFactory.address);
                if (proxyFactoryAddress)
                    this.networkFile.proxyFactory = { address: proxyFactoryAddress };
            }
        });
    }
    // Proxy model
    checkInitialization(contract, calledInitMethod) {
        // If there is an initializer called, assume it's ok
        if (calledInitMethod)
            return;
        // Otherwise, warn the user to invoke it
        const contractMethods = zos_lib_1.contractMethodsFromAbi(contract);
        const initializerMethods = contractMethods
            .filter(({ hasInitializer, name }) => hasInitializer || name === 'initialize')
            .map(({ name }) => name);
        if (initializerMethods.length === 0)
            return;
        zos_lib_1.Loggy.noSpin.warn(__filename, 'validateContract', `validate-contract`, `Possible initialization method (${lodash_uniq_1.default(initializerMethods).join(', ')}) found in contract. Make sure you initialize your instance.`);
    }
    // Proxy model
    _updateTruffleDeployedInformation(contractAlias, implementation) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractName = this.packageFile.contract(contractAlias);
            if (contractName) {
                const path = zos_lib_1.Contracts.getLocalPath(contractName);
                const data = zos_lib_1.FileSystem.parseJson(path);
                if (!data.networks) {
                    data.networks = {};
                }
                const networkId = yield zos_lib_1.ZWeb3.getNetwork();
                data.networks[networkId] = {
                    links: {},
                    events: {},
                    address: implementation.address,
                    // eslint-disable-next-line @typescript-eslint/camelcase
                    updated_at: Date.now(),
                };
                zos_lib_1.FileSystem.writeJson(path, data);
            }
        });
    }
    // Proxy model
    setProxiesAdmin(packageName, contractAlias, proxyAddress, newAdmin) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            const proxies = this._fetchOwnedProxies(packageName, contractAlias, proxyAddress);
            if (proxies.length === 0)
                return [];
            yield this.fetchOrDeploy(this.currentVersion);
            yield this._changeProxiesAdmin(proxies, newAdmin);
            return proxies;
        });
    }
    // Proxy model
    setProxyAdminOwner(newAdminOwner) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            yield this.fetchOrDeploy(this.currentVersion);
            yield this.project.transferAdminOwnership(newAdminOwner);
        });
    }
    // Proxy model
    _changeProxiesAdmin(proxies, newAdmin, project = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!project)
                project = this.project;
            yield async_1.allPromisesOrError(lodash_map_1.default(proxies, (aProxy) => __awaiter(this, void 0, void 0, function* () {
                yield project.changeProxyAdmin(aProxy.address, newAdmin);
                this.networkFile.updateProxy(aProxy, anotherProxy => (Object.assign({}, anotherProxy, { admin: newAdmin })));
            })));
        });
    }
    // Proxy model
    upgradeProxies(packageName, contractAlias, proxyAddress, initMethod, initArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            const proxies = this._fetchOwnedProxies(packageName, contractAlias, proxyAddress);
            if (proxies.length === 0)
                return [];
            yield this.fetchOrDeploy(this.currentVersion);
            // Update all out of date proxies
            yield async_1.allPromisesOrError(lodash_map_1.default(proxies, proxy => this._upgradeProxy(proxy, initMethod, initArgs)));
            return proxies;
        });
    }
    // Proxy model
    _upgradeProxy(proxy, initMethod, initArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const name = { packageName: proxy.package, contractName: proxy.contract };
                const contract = this.contractManager.getContractClass(proxy.package, proxy.contract);
                yield this._setSolidityLibs(contract);
                const currentImplementation = yield zos_lib_1.Proxy.at(proxy.address).implementation();
                const contractImplementation = yield this.project.getImplementation(name);
                const packageVersion = proxy.package === this.packageFile.name
                    ? this.currentVersion
                    : yield this.project.getDependencyVersion(proxy.package);
                let newImplementation;
                if (currentImplementation !== contractImplementation) {
                    yield this.project.upgradeProxy(proxy.address, contract, Object.assign({ initMethod,
                        initArgs }, name));
                    newImplementation = contractImplementation;
                }
                else {
                    zos_lib_1.Loggy.noSpin(__filename, '_upgradeProxy', `upgrade-proxy-${proxy.address}`, `Contract ${proxy.contract} at ${proxy.address} is up to date.`);
                    newImplementation = currentImplementation;
                }
                this.networkFile.updateProxy(proxy, aProxy => (Object.assign({}, aProxy, { implementation: newImplementation, version: zos_lib_1.semanticVersionToString(packageVersion) })));
            }
            catch (error) {
                error.message = `Proxy ${naming_1.toContractFullName(proxy.package, proxy.contract)} at ${proxy.address} failed to upgrade with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Proxy model
    _fetchOwnedProxies(packageName, contractAlias, proxyAddress, ownerAddress) {
        let criteriaDescription = '';
        if (packageName || contractAlias)
            criteriaDescription += ` contract ${naming_1.toContractFullName(packageName, contractAlias)}`;
        if (proxyAddress)
            criteriaDescription += ` address ${proxyAddress}`;
        const proxies = this.networkFile.getProxies({
            package: packageName || (contractAlias ? this.packageFile.name : undefined),
            contract: contractAlias,
            address: proxyAddress,
            kind: interfaces_1.ProxyType.Upgradeable,
        });
        if (lodash_isempty_1.default(proxies)) {
            zos_lib_1.Loggy.noSpin(__filename, '_fetchOwnedProxies', `fetch-owned-proxies`, `No contract instances that match${criteriaDescription} were found`);
            return [];
        }
        const expectedOwner = zos_lib_1.ZWeb3.toChecksumAddress(ownerAddress || this.networkFile.proxyAdminAddress);
        const ownedProxies = proxies.filter(proxy => !proxy.admin ||
            !expectedOwner ||
            zos_lib_1.ZWeb3.toChecksumAddress(proxy.admin) === expectedOwner);
        if (lodash_isempty_1.default(ownedProxies)) {
            zos_lib_1.Loggy.noSpin(__filename, '_fetchOwnedProxies', `fetch-owned-proxies`, `No contract instances that match${criteriaDescription} are owned by this project`);
        }
        return ownedProxies;
    }
    // Dependency Controller
    deployDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(lodash_map_1.default(this.packageFile.dependencies, (version, dep) => this.deployDependencyIfNeeded(dep, version)));
        });
    }
    // DependencyController
    deployDependencyIfNeeded(depName, depVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const dependency = new Dependency_1.default(depName, depVersion);
                if (dependency.isDeployedOnNetwork(this.network) ||
                    this.networkFile.dependencyHasMatchingCustomDeploy(depName))
                    return;
                zos_lib_1.Loggy.spin(__filename, 'deployDependencyIfNeeded', `deploy-dependency-${depName}`, `Deploying ${depName} dependency to network ${this.network}`);
                const deployment = yield dependency.deploy(this.txParams);
                this.networkFile.setDependency(depName, {
                    package: (yield deployment.getProjectPackage()).address,
                    version: deployment.version,
                    customDeploy: true,
                });
                zos_lib_1.Loggy.succeed(`deploy-dependency-${depName}`);
            }
            catch (error) {
                error.message = `Failed deployment of dependency ${depName} with error: ${error.message}`;
                throw error;
            }
        });
    }
    // DependencyController
    handleDependenciesLink() {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(lodash_concat_1.default(lodash_map_1.default(this.packageFile.dependencies, (version, dep) => this.linkDependency(dep, version)), lodash_map_1.default(this.networkFile.dependenciesNamesMissingFromPackage(), dep => this.unlinkDependency(dep))));
        });
    }
    // DependencyController
    unlinkDependency(depName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (yield this.project.hasDependency(depName)) {
                    zos_lib_1.Loggy.spin(__filename, 'unlinkDependency', `unlink-dependency-${depName}`, `Unlinking dependency ${depName}`);
                    yield this.project.unsetDependency(depName);
                    zos_lib_1.Loggy.succeed(`unlink-dependency-${depName}`);
                }
                this.networkFile.unsetDependency(depName);
            }
            catch (error) {
                throw Error(`Failed to unlink dependency ${depName} with error: ${error.message}`);
            }
        });
    }
    // DependencyController
    linkDependency(depName, depVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.networkFile.dependencyHasMatchingCustomDeploy(depName)) {
                    zos_lib_1.Loggy.onVerbose(__filename, 'linkDependency', `link-dependency-${depName}`, `Using custom deployment of ${depName}`);
                    const depInfo = this.networkFile.getDependency(depName);
                    return yield this.project.setDependency(depName, depInfo.package, depInfo.version);
                }
                if (!this.networkFile.dependencySatisfiesVersionRequirement(depName)) {
                    const dependencyInfo = new Dependency_1.default(depName, depVersion).getNetworkFile(this.network);
                    if (!dependencyInfo.packageAddress)
                        throw Error(`Dependency '${depName}' has not been published to network '${this.network}', so it cannot be linked. Hint: you can create a custom deployment of all unpublished dependencies by running 'zos push' with the '--deploy-dependencies' option.`);
                    zos_lib_1.Loggy.spin(__filename, 'linkDependency', `link-dependency-${depName}`, `Linking dependency ${depName} ${dependencyInfo.version}`);
                    yield this.project.setDependency(depName, dependencyInfo.packageAddress, dependencyInfo.version);
                    const depInfo = {
                        package: dependencyInfo.packageAddress,
                        version: dependencyInfo.version,
                    };
                    this.networkFile.setDependency(depName, depInfo);
                    zos_lib_1.Loggy.succeed(`link-dependency-${depName}`, `Linked dependency ${depName} ${dependencyInfo.version}`);
                }
            }
            catch (error) {
                error.message = `Failed to link dependency ${depName}@${depVersion} with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Contract model
    _errorForContractDeployed(packageName, contractAlias) {
        if (packageName === this.packageFile.name) {
            return this._errorForLocalContractDeployed(contractAlias);
        }
        else if (!this.packageFile.hasDependency(packageName)) {
            return `Dependency ${packageName} not found in project.`;
        }
        else if (!this.networkFile.hasDependency(packageName)) {
            return `Dependency ${packageName} has not been linked yet. Please run zos push.`;
        }
        else if (!new Dependency_1.default(packageName).getPackageFile().contract(contractAlias)) {
            return `Contract ${contractAlias} is not provided by ${packageName}.`;
        }
    }
    _updateZosVersionsIfNeeded(version) {
        if (this.networkFile.zosversion !== ZosVersion_2.ZOS_VERSION)
            this.networkFile.zosversion = version;
        if (this.packageFile.zosversion !== ZosVersion_2.ZOS_VERSION)
            this.packageFile.zosversion = version;
    }
}
exports.default = NetworkController;
//# sourceMappingURL=NetworkController.js.map